#!/usr/bin/env perl
package main; our $VERSION = '0.001004';

## -> Install me:
##
## Config me    -> $ vim blagger.conf
## Start me     -> $ hypnotoad blagger
## Blag stuff   -> $ ./blagger blag this-blag-entry
##
## See 'examples/' for example posts.


BEGIN { local $@; my @failed;
  my @prereq = qw/
    List::Objects::WithUtils
    Mojolicious
    Path::Tiny
    Text::Markdown
  /;
  for my $mod (@prereq) {
    eval "require $mod; 1";
    if ($@) {
      warn $@;
      push @failed, $mod;
    }
  }
  die "Failed to load modules:\n ".join "\n ", @failed
    if @failed;
};


package Blag::Cfg;
use strict; use warnings;
use Carp 'confess';

sub TITLE   () { 0 }
sub AUTHOR  () { 1 }
sub DESC    () { 2 }
sub CONTACT () { 3 }

sub new {
  my ($class, %params) = @_;
  bless [
    ($params{title}  || 'my underconfigured blag!'),  # TITLE
    ($params{author} || 'No One'),                    # AUTHOR
    ($params{description} || 'Is this internet?'),    # DESC
    ($params{contact} || '/dev/null' ),               # CONTACT
  ], $class
}

sub author  { $_[0]->[AUTHOR]  }
sub contact { $_[0]->[CONTACT] }
sub title   { $_[0]->[TITLE]   }
sub version { $::VERSION }
sub description { $_[0]->[DESC] }


package Blag::Post;
use strict; use warnings;
use Carp 'confess';
use List::Objects::WithUtils;
use Path::Tiny ();
use Text::Markdown 'markdown';

# Post format:
#   Topic: One-liner summary
#   Date: YYYY-MM-DD
#   <Single empty line>
#   <Markdown content>

sub PATH     () { 0 }
sub TOPIC    () { 1 }
sub DATE     () { 2 }
sub BLAGID   () { 3 }
sub HTML     () { 4 }

sub _parseblag {
  my ($path) = @_;
  confess "Expected a Path::Tiny object"
    unless ref $path and $path->can('lines_utf8');

  my @lines = $path->lines_utf8;
  my $full = array(@lines);
  my $header   = $full->items_before(sub { $_ eq "\n" });
  my $contents = $full->items_after(sub { $_ eq "\n" });

  my $topicline = 
    $header->grep(sub { index($_[0], 'Topic: ') == 0 })->get(0);
  my $dateline =
    $header->grep(sub { index($_[0], 'Date: ') == 0 })->get(0);

  warn "Malformed blag post at ".$path->absolute
    unless $topicline and $dateline;
  warn "Empty blag post at ".$path->absolute
    unless $contents->count;

  my $topic = substr($topicline, 7);
  warn "Blag post at @{[$path->absolute]} is missing a Topic:\n"
    unless $topic;
  my $date = substr($dateline, 6);
  warn "Blag post at @{[$path->absolute]} is missing a Date:\n"
    unless $date;

  hash(
    topic => $topic,
    date  => $date,
    contents => $contents,
  )
}

sub _renderblag {
  my ($contents) = @_;
  markdown( join('', @$contents), { tab_width => 2 } )
}

sub from_file {
  my ($class, $filepath) = @_;
  confess "Expected a path" unless defined $filepath;

  my $self = [];

  my $file = Path::Tiny::path($filepath);
  confess "Nonexistant post path ($filepath) ".$file->absolute
    unless $file->exists;

  my $item = _parseblag($file);
  my $topic = $item->get('topic');
  my $date  = $item->get('date');

  my $contents = $item->get('contents');
  my $html = _renderblag($contents);

  my ($blagid) = $file->basename =~ /(.+)\.(?:mkdn|blag)$/;
  
  bless [
    $file,             ## PATH    (Path::Tiny obj, stringifies)
    $topic,            ## TOPIC
    $date,             ## DATE
    $blagid,           ## BLAGID
    $html,             ## HTML
  ], $class
}

sub html  { $_[0]->[HTML]  }
sub path  { $_[0]->[PATH]  }
sub topic { $_[0]->[TOPIC] }
sub date  { $_[0]->[DATE]  }
sub id    { $_[0]->[BLAGID] }


package Blag::PostList::Element;
use strict; use warnings;
use Carp 'confess';
use Scalar::Util 'blessed';
use POSIX ();

sub POST      () { 0 }
sub MTIME     () { 1 }
sub LAST_EDIT () { 2 }

sub new {
  my ($class, $post) = @_;

  confess "Expected a Blag::Post"
    unless blessed $post and $post->isa('Blag::Post');

  my $mtime = $post->path->stat->mtime;
  my $mtime_human = POSIX::strftime(
    "%Y-%m-%d %H:%M:%S",
    localtime($mtime)
  );

  bless [
    $post,         ## POST   (Blag::Post obj)
    $mtime,        ## MTIME  (as of when we saw this post)
    $mtime_human,  ## LAST_EDIT
  ], $class
}

sub post      { $_[0]->[POST]  }
sub mtime     { $_[0]->[MTIME] }
sub last_edit { $_[0]->[LAST_EDIT] }


package Blag::PostList;
use strict; use warnings;
use Carp 'confess';
use List::Objects::WithUtils;
use Path::Tiny ();

sub PATH     () { 0 }
sub POSTHASH () { 1 }

sub from_dir {
  my ($class, $dirpath) = @_;

  my $dir = Path::Tiny::path($dirpath);
  my $self = [
    $dir,     ## PATH
    hash,     ## POSTHASH
  ];
  bless $self, $class;

  # Create initial Posts and add hash() of PostList::Elements:
  $self->scan;

  $self
}

sub scan {
  my ($self) = @_;
  my $dir = $self->path;

  confess "Not a directory: $dir" unless $dir->is_dir;

  SCAN: for my $child ($dir->children) {
    my $basename = $child->basename;
    my ($maybe_id) = $basename =~ /(.+)\.(?:mkdn|blag)$/;
    next SCAN unless $maybe_id;

    if ( $self->posts->exists($maybe_id) ) {
      my $current = $self->posts->get($maybe_id);
      unless ($current->post->path->basename eq $child->basename) {
        warn "Possible ID conflict for $maybe_id"
          if $current->post->path->exists;
      }
      next SCAN if $child->stat->mtime == $current->mtime;
    }

    $self->_reset_post( $maybe_id => $child );
  }

  $self
}

sub _reset_post {
  my ($self, $id, $path) = @_;
  my $post = Blag::Post->from_file( $path );
  my $post_meta = Blag::PostList::Element->new( $post );
  $self->posts->set( $id => $post_meta );
  $post_meta
}

sub as_array {
  my ($self) = @_;
  $self->posts->values
}

sub by_date {
  my ($self) = @_;
  $self->posts->values
    ->sort_by(sub { $_->post->date })
    ->reverse
}

sub by_mtime {
  my ($self) = @_;
  $self->posts->values
    ->sort_by(sub { $_->mtime })
}

sub by_topic {
  my ($self) = @_;
  $self->posts->values
    ->sort_by(sub { $_->post->topic })
}

sub get {
  my ($self, $id) = @_;
  my $post_meta = $self->posts->get($id);
  my $old_mtime = $post_meta->mtime;
  my $cur_mtime = $post_meta->post->path->stat->mtime;
  unless ($old_mtime == $cur_mtime) {
    $post_meta = $self->_reset_post( $id => $post_meta->post->path )
  }
  $post_meta
}

sub path  { $_[0]->[PATH]  }
sub posts { $_[0]->[POSTHASH] }


package Mojolicious::Command::blag;
use feature 'say';
use FindBin '$Bin';
use Mojo::Base 'Mojolicious::Command';
use Path::Tiny;
use POSIX ();

has description => "Blag about stuff.\n";

sub run {
  my ($self, $post) = @_;
  die "Usage: blagger blag new-blag-entry-id\n" unless $post;

  my $postdir = $self->app->config->{blagcfg}->{post_directory};
  die "No post_directory configured\n" unless $postdir;
  $postdir =~ s/%X/$Bin/g;

  my $file = path($postdir)->child($post.".mkdn");
  die "Post exists at $file\n" if $file->exists;

  print "Topic: ";
  my $topic = <STDIN>; chomp $topic;
  my $date = POSIX::strftime( "%Y-%m-%d", localtime );  

  my @tmp = (
    "Topic: $topic\n",
    "Date: $date\n\n",
    "## Gimme some header\n\n",
    "Hi, put some Markdown here.\n",
  );

  $file->spew_utf8(@tmp);

  system($ENV{EDITOR}, "$file");

  ## FIXME
  ##  Create a pendingposts dir
  ##  Disallow creation if exists in current or pending
  ##  Prompt after save wrt whether to pull out of pending
  ##  Provide a 'reblag' editor command?
}

package main;
use 5.10.1;
use strict; use warnings;
use FindBin '$Bin';

use Mojolicious::Lite;
plugin 'Config';

my $cfghash = app->config->{blagcfg} || +{};

my $postdir = $cfghash->{post_directory} || '%X/posts';
$postdir =~ s/%X/$Bin/g;

my $postlist = Blag::PostList->from_dir( $postdir );
my $blagcfg  = Blag::Cfg->new(%$cfghash);

get '/style.css' => sub { 
  my $self = shift;
  my $tmpl = $cfghash->{css_template} || 'style';
  $self->render(template => $tmpl, format => 'css')
};

get '/' => sub {
  my $self = shift;

  $self->stash( blagcfg  => $blagcfg );
  $self->stash( postlist => $postlist->scan );

  my $tmpl = $cfghash->{index_template} || 'index';
  $self->render($tmpl);
};

get '/post/:id' => sub {
  my $self = shift;

  my $id   = $self->param('id');
  my $post_meta = $postlist->get($id);
  unless ($post_meta) {
    $self->render( text => 'No such blag!', status => 404 );
    return
  }

  $self->stash( post => $post_meta->post );
  $self->stash( blagcfg => $blagcfg );

  my $tmpl = $cfghash->{post_template} || 'post';
  $self->render($tmpl);
};

app->start;


